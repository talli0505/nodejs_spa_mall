"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPIGenerator = void 0;
const lodash_1 = require("./lib/lodash");
const errors_1 = require("./errors");
const zod_is_type_1 = require("./lib/zod-is-type");
class OpenAPIGenerator {
    constructor(definitions) {
        this.definitions = definitions;
        this.schemaRefs = {};
        this.paramRefs = {};
        this.pathRefs = {};
        this.rawComponents = [];
        this.sortDefinitions();
    }
    generateDocument(config) {
        this.definitions.forEach(definition => this.generateSingle(definition));
        return Object.assign(Object.assign({}, config), { components: this.buildComponents(), paths: this.pathRefs });
    }
    generateComponents() {
        this.definitions.forEach(definition => this.generateSingle(definition));
        return {
            components: this.buildComponents(),
        };
    }
    buildComponents() {
        var _a, _b;
        const rawComponents = {};
        this.rawComponents.forEach(({ componentType, name, component }) => {
            var _a;
            (_a = rawComponents[componentType]) !== null && _a !== void 0 ? _a : (rawComponents[componentType] = {});
            rawComponents[componentType][name] = component;
        });
        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, ((_a = rawComponents.schemas) !== null && _a !== void 0 ? _a : {})), this.schemaRefs), parameters: Object.assign(Object.assign({}, ((_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {})), this.paramRefs) });
    }
    sortDefinitions() {
        const generationOrder = [
            'schema',
            'parameter',
            'route',
        ];
        this.definitions.sort((left, right) => {
            const leftIndex = generationOrder.findIndex(type => type === left.type);
            const rightIndex = generationOrder.findIndex(type => type === right.type);
            return leftIndex - rightIndex;
        });
    }
    generateSingle(definition) {
        switch (definition.type) {
            case 'parameter':
                this.generateParameterDefinition(definition.schema);
                return;
            case 'schema':
                this.generateSchemaDefinition(definition.schema);
                return;
            case 'route':
                this.generateSingleRoute(definition.route);
                return;
            case 'component':
                this.rawComponents.push(definition);
                return;
        }
    }
    generateParameterDefinition(zodSchema) {
        const metadata = this.getMetadata(zodSchema);
        const result = this.generateParameter(zodSchema);
        if (metadata === null || metadata === void 0 ? void 0 : metadata.refId) {
            this.paramRefs[metadata.refId] = result;
        }
        return result;
    }
    getParameterRef(schemaMetadata, external) {
        const parameterMetadata = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.param;
        const existingRef = (schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.refId)
            ? this.paramRefs[schemaMetadata.refId]
            : undefined;
        if (!(schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.refId) || !existingRef) {
            return undefined;
        }
        if ((parameterMetadata && existingRef.in !== parameterMetadata.in) ||
            ((external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in)) {
            throw new errors_1.ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
                key: 'in',
                values: (0, lodash_1.compact)([
                    existingRef.in,
                    external === null || external === void 0 ? void 0 : external.in,
                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in,
                ]),
            });
        }
        if ((parameterMetadata && existingRef.name !== parameterMetadata.name) ||
            ((external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name))) {
            throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                key: 'name',
                values: (0, lodash_1.compact)([
                    existingRef.name,
                    external === null || external === void 0 ? void 0 : external.name,
                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name,
                ]),
            });
        }
        return {
            $ref: `#/components/parameters/${schemaMetadata.refId}`,
        };
    }
    generateInlineParameters(zodSchema, location) {
        const metadata = this.getMetadata(zodSchema);
        const parameterMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.param;
        const referencedSchema = this.getParameterRef(metadata, { in: location });
        if (referencedSchema) {
            return [referencedSchema];
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodObject')) {
            const propTypes = zodSchema._def.shape();
            const parameters = Object.entries(propTypes).map(([key, schema]) => {
                var _a;
                const innerMetadata = this.getMetadata(schema);
                const referencedSchema = this.getParameterRef(innerMetadata, {
                    in: location,
                    name: key,
                });
                if (referencedSchema) {
                    return referencedSchema;
                }
                const innerParameterMetadata = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.param;
                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) &&
                    innerParameterMetadata.name !== key) {
                    throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                        key: 'name',
                        values: [key, innerParameterMetadata.name],
                    });
                }
                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) &&
                    innerParameterMetadata.in !== location) {
                    throw new errors_1.ConflictError(`Conflicting location for parameter ${(_a = innerParameterMetadata.name) !== null && _a !== void 0 ? _a : key}`, {
                        key: 'in',
                        values: [location, innerParameterMetadata.in],
                    });
                }
                return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
            });
            return parameters;
        }
        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
            throw new errors_1.ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
                key: 'in',
                values: [location, parameterMetadata.in],
            });
        }
        return [
            this.generateParameter(zodSchema.openapi({ param: { in: location } })),
        ];
    }
    generateParameter(zodSchema) {
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.param;
        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
        if (!paramName) {
            throw new errors_1.MissingParameterDataError({ missingField: 'name' });
        }
        if (!paramLocation) {
            throw new errors_1.MissingParameterDataError({
                missingField: 'in',
                paramName,
            });
        }
        const required = !zodSchema.isOptional() && !zodSchema.isNullable();
        const schema = this.generateSimpleSchema(zodSchema);
        return Object.assign({ in: paramLocation, name: paramName, schema,
            required }, (paramMetadata ? this.buildParameterMetadata(paramMetadata) : {}));
    }
    /**
     * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
     */
    generateSimpleSchema(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi
            ? zodSchema._def.openapi
            : innerSchema._def.openapi;
        const refId = metadata === null || metadata === void 0 ? void 0 : metadata.refId;
        if (refId && this.schemaRefs[refId]) {
            const referenceObject = {
                $ref: `#/components/schemas/${refId}`,
            };
            const nullableMetadata = zodSchema.isNullable() ? { nullable: true } : {};
            const appliedMetadata = this.applySchemaMetadata(nullableMetadata, metadata);
            if (Object.keys(appliedMetadata).length > 0) {
                return {
                    allOf: [referenceObject, appliedMetadata],
                };
            }
            return referenceObject;
        }
        const result = (metadata === null || metadata === void 0 ? void 0 : metadata.type)
            ? {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
            }
            : this.toOpenAPISchema(innerSchema, zodSchema.isNullable());
        return metadata
            ? this.applySchemaMetadata(result, metadata)
            : (0, lodash_1.omitBy)(result, lodash_1.isNil);
    }
    generateInnerSchema(zodSchema, metadata) {
        const simpleSchema = this.generateSimpleSchema(zodSchema);
        if (simpleSchema.$ref) {
            return simpleSchema;
        }
        return metadata
            ? this.applySchemaMetadata(simpleSchema, metadata)
            : simpleSchema;
    }
    generateSchemaDefinition(zodSchema) {
        const metadata = this.getMetadata(zodSchema);
        const refId = metadata === null || metadata === void 0 ? void 0 : metadata.refId;
        const simpleSchema = this.generateSimpleSchema(zodSchema);
        const result = metadata
            ? this.applySchemaMetadata(simpleSchema, metadata)
            : simpleSchema;
        if (refId) {
            this.schemaRefs[refId] = result;
        }
        return result;
    }
    getRequestBody(bodySchema) {
        if (!bodySchema) {
            return;
        }
        const schema = this.generateInnerSchema(bodySchema);
        const metadata = this.getMetadata(bodySchema);
        return {
            description: metadata === null || metadata === void 0 ? void 0 : metadata.description,
            required: !bodySchema.isOptional(),
            content: {
                // TODO: Maybe should be coming from metadata
                'application/json': {
                    schema,
                },
            },
        };
    }
    getParameters(request) {
        var _a, _b;
        if (!request) {
            return [];
        }
        const queryParameters = request.query
            ? this.generateInlineParameters(request.query, 'query')
            : [];
        const pathParameters = request.params
            ? this.generateInlineParameters(request.params, 'path')
            : [];
        const headerParameters = (_b = (_a = request.headers) === null || _a === void 0 ? void 0 : _a.flatMap(header => this.generateInlineParameters(header, 'header'))) !== null && _b !== void 0 ? _b : [];
        return [...pathParameters, ...queryParameters, ...headerParameters];
    }
    generateSingleRoute(route) {
        const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
        const generatedResponses = (0, lodash_1.mapValues)(responses, response => {
            return this.getResponse(response);
        });
        const parameters = this.getParameters(request);
        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
        const routeDoc = {
            [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), (parameters.length > 0 ? { parameters } : {})), (requestBody ? { requestBody } : {})), { responses: generatedResponses }),
        };
        this.pathRefs[path] = Object.assign(Object.assign({}, this.pathRefs[path]), routeDoc);
        return routeDoc;
    }
    getResponse(response) {
        const description = this.descriptionFromResponseConfig(response);
        if ((0, zod_is_type_1.isZodType)(response, 'ZodVoid')) {
            return { description };
        }
        const responseSchema = this.generateInnerSchema(response.schema);
        return {
            description,
            headers: response.headers,
            links: response.links,
            content: {
                [response.mediaType]: {
                    schema: responseSchema,
                },
            },
        };
    }
    descriptionFromResponseConfig(response) {
        if ((0, zod_is_type_1.isZodType)(response, 'ZodVoid')) {
            const metadata = this.getMetadata(response);
            if (!(metadata === null || metadata === void 0 ? void 0 : metadata.description)) {
                throw new errors_1.MissingResponseDescriptionError();
            }
            return metadata.description;
        }
        if (response.description) {
            return response.description;
        }
        const metadata = this.getMetadata(response.schema);
        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.description)) {
            throw new errors_1.MissingResponseDescriptionError();
        }
        return metadata.description;
    }
    toOpenAPISchema(zodSchema, isNullable) {
        var _a, _b, _c, _d, _e;
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNull')) {
            return { type: 'null' };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodString')) {
            return {
                type: 'string',
                nullable: isNullable ? true : undefined,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNumber')) {
            return {
                type: 'number',
                minimum: (_a = zodSchema.minValue) !== null && _a !== void 0 ? _a : undefined,
                maximum: (_b = zodSchema.maxValue) !== null && _b !== void 0 ? _b : undefined,
                nullable: isNullable ? true : undefined,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodBoolean')) {
            return {
                type: 'boolean',
                nullable: isNullable ? true : undefined,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDefault')) {
            const innerSchema = zodSchema._def.innerType;
            return this.generateInnerSchema(innerSchema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEffects') &&
            zodSchema._def.effect.type === 'refinement') {
            const innerSchema = zodSchema._def.schema;
            return this.generateInnerSchema(innerSchema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodLiteral')) {
            return {
                type: typeof zodSchema._def.value,
                nullable: isNullable ? true : undefined,
                enum: [zodSchema._def.value],
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEnum')) {
            // ZodEnum only accepts strings
            return {
                type: 'string',
                nullable: isNullable ? true : undefined,
                enum: zodSchema._def.values,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNativeEnum')) {
            const enumValues = Object.values(zodSchema._def.values);
            // ZodNativeEnum can accepts number values for enum but in odd format
            // Not worth it for now so using plain string
            return {
                type: 'string',
                nullable: isNullable ? true : undefined,
                enum: enumValues,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodObject')) {
            return this.toOpenAPIObjectSchema(zodSchema, isNullable);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodArray')) {
            const itemType = zodSchema._def.type;
            return {
                type: 'array',
                items: this.generateInnerSchema(itemType),
                minItems: (_c = zodSchema._def.minLength) === null || _c === void 0 ? void 0 : _c.value,
                maxItems: (_d = zodSchema._def.maxLength) === null || _d === void 0 ? void 0 : _d.value,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodUnion')) {
            const options = this.flattenUnionTypes(zodSchema);
            return {
                anyOf: options.map(schema => this.generateInnerSchema(schema)),
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDiscriminatedUnion')) {
            const options = [...zodSchema.options.values()];
            return {
                anyOf: options.map(schema => this.generateInnerSchema(schema)),
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodIntersection')) {
            const subtypes = this.flattenIntersectionTypes(zodSchema);
            return {
                allOf: subtypes.map(schema => this.generateInnerSchema(schema)),
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodRecord')) {
            const propertiesType = zodSchema._def.valueType;
            return {
                type: 'object',
                additionalProperties: this.generateInnerSchema(propertiesType),
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodUnknown')) {
            return {};
        }
        const refId = (_e = this.getMetadata(zodSchema)) === null || _e === void 0 ? void 0 : _e.refId;
        throw new errors_1.UnknownZodTypeError({
            currentSchema: zodSchema._def,
            schemaName: refId,
        });
    }
    isOptionalSchema(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEffects')) {
            return this.isOptionalSchema(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDefault')) {
            return this.isOptionalSchema(zodSchema._def.innerType);
        }
        return zodSchema.isOptional();
    }
    toOpenAPIObjectSchema(zodSchema, isNullable) {
        var _a, _b, _c;
        const extendedFrom = (_a = zodSchema._def.openapi) === null || _a === void 0 ? void 0 : _a.extendedFrom;
        const propTypes = zodSchema._def.shape();
        const unknownKeysOption = zodSchema._unknownKeys;
        const requiredProperties = Object.entries(propTypes)
            .filter(([_key, type]) => !this.isOptionalSchema(type))
            .map(([key, _type]) => key);
        const schemaProperties = (0, lodash_1.mapValues)(propTypes, propSchema => this.generateInnerSchema(propSchema));
        let alreadyRegistered = [];
        let alreadyRequired = [];
        if (extendedFrom) {
            const registeredSchema = this.schemaRefs[extendedFrom];
            if (!registeredSchema) {
                throw new Error(`Attempt to extend an unregistered schema with id ${extendedFrom}.`);
            }
            const registeredProperties = (_b = registeredSchema.properties) !== null && _b !== void 0 ? _b : {};
            alreadyRegistered = Object.keys(registeredProperties).filter(propKey => {
                return (0, lodash_1.objectEquals)(schemaProperties[propKey], registeredProperties[propKey]);
            });
            alreadyRequired = (_c = registeredSchema.required) !== null && _c !== void 0 ? _c : [];
        }
        const properties = (0, lodash_1.omit)(schemaProperties, alreadyRegistered);
        const additionallyRequired = requiredProperties.filter(prop => !alreadyRequired.includes(prop));
        const objectData = Object.assign(Object.assign(Object.assign({ type: 'object', properties }, (isNullable ? { nullable: true } : {})), (additionallyRequired.length > 0
            ? { required: additionallyRequired }
            : {})), (unknownKeysOption === 'passthrough'
            ? { additionalProperties: true }
            : {}));
        if (extendedFrom) {
            return {
                allOf: [{ $ref: `#/components/schemas/${extendedFrom}` }, objectData],
            };
        }
        return objectData;
    }
    flattenUnionTypes(schema) {
        if (!(0, zod_is_type_1.isZodType)(schema, 'ZodUnion')) {
            return [schema];
        }
        const options = schema._def.options;
        return options.flatMap(option => this.flattenUnionTypes(option));
    }
    flattenIntersectionTypes(schema) {
        if (!(0, zod_is_type_1.isZodType)(schema, 'ZodIntersection')) {
            return [schema];
        }
        const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
        const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
        return [...leftSubTypes, ...rightSubTypes];
    }
    unwrapChained(schema) {
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodOptional') || (0, zod_is_type_1.isZodType)(schema, 'ZodNullable')) {
            return this.unwrapChained(schema.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodDefault')) {
            return this.unwrapChained(schema._def.innerType);
        }
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodEffects') &&
            schema._def.effect.type === 'refinement') {
            return this.unwrapChained(schema._def.schema);
        }
        return schema;
    }
    buildSchemaMetadata(metadata) {
        // A place to omit all custom keys added to the openapi
        return (0, lodash_1.omitBy)((0, lodash_1.omit)(metadata, ['param', 'refId', 'extendedFrom']), lodash_1.isNil);
    }
    buildParameterMetadata(metadata) {
        return (0, lodash_1.omitBy)(metadata, lodash_1.isNil);
    }
    getMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi
            ? zodSchema._def.openapi
            : innerSchema._def.openapi;
        return metadata;
    }
    applySchemaMetadata(initialData, metadata) {
        return (0, lodash_1.omitBy)(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), lodash_1.isNil);
    }
}
exports.OpenAPIGenerator = OpenAPIGenerator;
